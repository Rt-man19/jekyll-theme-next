---

title: 网络协议之TCP和UDP

categories:

- 网络

tags:

---
# 网络协议之TCP和UDP



## TCP 和 UDP 的区别

- TCP是面向连接的
- UDP是面向无连接的

在互相通信之前，面向连接的协议会先建立连接，所谓建立连接是为了在客户端和服务端维护连接而建立的一些数据结构来维护双方的交互关系，用这样的数据结构来保证面向连接的特性

**TCP 提供可靠性交付** 通过TCP传输的数据可以无差错、不丢失、不重复、顺序到达。

**UDP则继承了IP包的特性** 它没有任何可靠性保证，无法保证不丢失数据，也无法保证顺序到达



**TCP 是面向字节流的** 发送的时候是一个流，没头没尾，这也是TCP自己的状态维护做的事情。

**UDP是基于数据报的** 一个一个地发，一个一个地收



**TCP是可以控制拥塞的** 它意识到丢包或者网络状况不佳后会根据具体情况调整自己，看看是不是发快了，需不需要慢点发

**UDP不会这样，应用让它发它就发，不会管你丢包还是网络不佳**



**TCP 可以说是一个有状态服务** 它会记录着数据发送了没有、收到了没有、发送到哪了、应该接受哪个

**UDP可以说是一个无状态服务，它不管这些，发送出去就不归他管了**



## UDP 协议

### UDP包头

包的传输过程先忽略，当UDP数据包到达目标主机之后发现MAC地址匹配，于是取下将剩下的包发送给IP层处理，在IP头里有个8位协议，里面会存放这个包的数据是UDP还是TCP，这里就当它是UDP的数据包，如果知道UDP头的格式就能从数据里将它解析出来，处理完传输层的事情，内核的事情就基本完成了，剩下的就交给应用处理了。无论TCP还是UDP应用，它都会监听一个端口号，就是使用端口号来区分应用程序，所以无论如何端口号都不能冲突。所以按理说 TCP和UDP包头都应该有端口号来将具体的数据传输给相应的应用程序

![t8QEcj.png](https://s1.ax1x.com/2020/06/01/t8QEcj.png)

可以看到，UDP的包头确实包含了有源端口和目的端口号，因为需要互相通信，这很容易理解。

### UDP三大特点

- **沟通简单**: 它没有大量的数据结构，处理逻辑，它相信网络世界是美好的，默认就能轻易送达，并且不容易被丢弃的
- **轻信他人**: 它不会主动建立连接，但它就监听在一个端口号，谁都可以向它发送数据，它也可以传送数据给任何人
- **愣头青**: 它不会根据网络问题进行发包的拥塞控制，无论网络丢包成什么样，它该怎么发还是怎么发



### UDP使用场景

- 需要资源少，在网络较好的内网或者对丢包不敏感的应用。

- 不需要一对一沟通、建立连接，而是可以广播的应用

  UDP 的不面向连接的特性可以使它承载广播或多播的协议，比如DHCP就是一种广播的形式，它就是基于UDP协议的。

- 适合需要处理速度极快、时延低，可以容忍少量丢包的应用

#### 使用场景一: QUIC

原本的网页或APP访问都是基于HTTP协议的，HTTP协议是基于TCP协议的，建立连接都会进行多次交互，对于主流的移动互联网来说建立一次连接需要时间会比较长，而且TCP可能还会断了重连，这些都非常耗时。并且目前HTTP协议往往都采用多个数据通道共享一个连接的情况，这样本是为了加快传输速度的，但是TCP的严格顺序策略哪怕是共享同一个连接，前一个包不来，后面的包即使跟前面的包没有任何关系也要排队等待，这也加大了延时。

而**QUIC(Quick UDP Internet Connections,快速UDP互联网连接)**是谷歌提出的一种基于UDP改进的通信协议，其目的是降低网络通信延迟、提供更好的用户交互体验

QUIC在应用层上，它会自己实现快速建立连接、减少重传延时、自适应拥塞控制。



#### 使用场景二: 流媒体的协议

现在的直播协议多使用的是RTMP协议，RTMP协议是基于TCP的，TCP的严格顺序传输保证前一个数据包收到了，下一个才能确认，如果前一个数据包没收到，就算后面的包收到了也要放到缓存中等待。对于直播平台显然不合适，因为老的视频帧丢了其实也就丢了，就算再传过来用户也不在意了，他们要看新的了，如果老是没来就等着，卡顿了，新的也看不了，那就会丢失客户，所以直播，实时性比较比较重要，宁可丢包，也不要卡顿的。另外，对于丢包，其实对于视频播放来讲，有的包可以丢，有的包不能丢，因为视频的连续帧里面，有的帧重要，有的不重要，如果必须要丢包，隔几个帧丢一个，其实看视频的人不会感知，但是如果连续丢帧，就会感知了，因而在网络不好的情况下，应用希望选择性的丢帧。还有就是当网络不好的时候，TCP 协议会主动降低发送速度，这对本来当时就卡的看视频来讲是要命的，应该应用层马上重传，而不是主动让步。因而，很多直播应用，都基于 UDP 实现了自己的视频传输协议。



## TCP协议

TCP之所以那么复杂是因为它秉承的是"性恶论"，它认为网络环境是恶劣的，丢包、拥塞、乱序问题是常有的，因此需要从算法层面保证可靠性

### TCP包头

![t8JCEn.png](https://s1.ax1x.com/2020/06/01/t8JCEn.png)

首先源端口和目标端口是必不可少的，如果没有这两个就不知道数据要发送到哪个应用

接下来是包的序号，序号是用来保证传输过程中不乱序的问题，不编号就无法确认哪个包先来，哪个包后来

然后是确认序号，这是用来保证不丢包的问题，发出去的包应该要有确认，不然就无从得知对方是否收到了包，如果没有收到就重新发送，直到送达位置。

接下来是一些状态位: 	SYN是发起一个连接，ACK是回复，RST是重新连接，FIN是结束连接等。

窗口大小也很重要。TCP要做到流量控制，通信双方都要声明一个窗口，用来标识自己能够处理的能力，也就是告诉对方，别发送的太快，也别发送的太慢

TCP是靠谱的协议，但这并不说明网络环境好。从IP层面来说，网络环境真的很差，那它是没有任何可靠性保证的，作为IP层的上层，TCP对此无能为力。也就是说，IP层丢不丢包，TCP管不着，但在TCP层面，它会尽量保证可靠性。

通过对TCP包头的解析，要掌握TCP协议，重点应该关注以下几点:

- 顺序问题
- 丢包问题
- 连接维护
- 流量控制
- 拥塞控制

### TCP三次握手

之前说的所有问题，首先都需要先建立一个连接，所以先来介绍连接维护的问题

TCP的建立连接，通常都被称为三次握手

> A: 你好，我是A
>
> B: 你好A，我是B
>
> A: 你好B

这个过程简单来说就是 请求---> 应答 ---> 应答之应答,这三个回合，但这里面还有很多细节指的描述

首先：**为什么是三次，而不是两次? 如果为了可靠性，为什么不能是四次?**

> 为了解答这个问题，需要假设这个网络通道是非常不可靠的。
>
> A发起了第一个请求，没有收到回复时，有很多的可能性；比如: 请求包丢了、绕路导致超时了，或者B不想跟A建立连接。
>
> 这种情况下A是不能确认是以上哪种原因导致的，于是它会一次又一次的发送，直到有一个包到达了B，如果B收到了请求包而没有回复，那么A就会认为这个包还是没有到达B，就会继续发送请求。
>
> B收到了请求包，知道了A的存在，并且知道了A想要和我建立连接，如果这时B不想建立连接，则A会在重试几次之后放弃，连接失败，这没有问题；如果B也想建立连接，则会发送应答包给A。
>
> 这时，对于B来说它不知道应答包是否到达了A，B当然也不能认为连接已经建立了，因为应答包也可能会丢、绕路超时，或者A挂了都有可能。
>
> B发送的应答包可能会发送多次，但只要有一次到达了A，A就认为连接已经建立了，对于A来说，它发送的消息是有来有回的，之后A会给B发送应答之应答包。
>
> 当然A发送给B的应答之应答还是有可能会丢、也可能会绕路，按理来说还要有应答之应答之应答，这样下去就没底了。所以四次握手是可以的，四十次都可以，关键是就算是四百次握手也不能保证连接通道真的可靠的，只要双方的信息都都有来有回就基本可以了。
>
> 连接建立、双方做了简单的通信之后断开了连接，这时A绕路的请求包到达了B，B会认为A又一次发起了请求，如果是两次握手的话，此时连接已经建立了，B会一直等待A发送数据，这是白白浪费B的资源，所以两次握手是不行的。

三次握手除了建立连接之外，主要还是为了沟通TCP包的序号问题。

A要告诉B，我这边发送的包的序号是从多少开始的，同样B也要告诉A，它发送的包的序号是从多少开始的。



![t8r8nx.png](https://s1.ax1x.com/2020/06/01/t8r8nx.png)

以上是双方建立连接过程中双方的状态变化时序图

一开始，客户端和服务端都处于 CLOSED 状态。先是服务端主动监听某个端口，处于 LISTEN 状态。然后客户端主动发起连接 SYN，之后处于 SYN-SENT 状态。服务端收到发起的连接，返回 SYN，并且 ACK 客户端的 SYN，之后处于 SYN-RCVD 状态。客户端收到服务端发送的 SYN 和 ACK 之后，发送 ACK 的 ACK，之后处于 ESTABLISHED 状态，因为它一发一收成功了。服务端收到 ACK 的 ACK 之后，处于 ESTABLISHED 状态，因 为它也一发一收了。



### TCP四次挥手

介绍完握手在来说说挥手，好说好散，有始有终。通常被称为四次挥手

> A: B啊，我不想玩了
>
> B: 哦，我知道了
>
> 这个时候只是A不想玩了，这个时候B是不能在ACK的时候直接关闭连接的，因为A很可能是发送完了最后的数据才准备关闭连接，但B还没有做完自己的事，它可能还有数据发送，处于半关闭状态
>
> 这个时候A可以选择不再接收数据，也可以选择最后再接收一段数据，等待 B 也主动关闭。
>
> B: A啊，我也不玩了，拜拜
>
> A: 好的，拜拜

这样整个连接就关闭了，这是一个挥手的大概流程，但是上面这只是和平分手的情况，还可能会有异常情况

> A说不玩了之后，B说知道了，这个回合没有问题，因为之前双方处于合作关系，如果A说不玩了，没有收到B的回复，那它会重新发送“不玩了”，在这个回合结束之后 就可能会有异常出现了
>
> 一种情况是： A说完"不玩了"之后直接跑路，这是会有问题的，因为这是B还没有发起结束，A直接跑路那么B就算发送结束也得不到应答，B 就不知道该怎么办了
>
> 另一种情况: A说完"不玩了"之后，B直接跑路，也是有问题的，因为A不知道B是否还有事情需要处理，还是过一会发起结束

为了解决上面的问题，TCP协议专门设计了几个状态来处理这些问题

![t8gLcQ.png](https://s1.ax1x.com/2020/06/01/t8gLcQ.png)

以上是四次挥手过程中双方状态变化的时序图

> A 发送释放报文后进入FIN_WAIT_1状态，B收到之后回复确认信息，并进入CLOSED_WAIT状态
>
> A收到B的确认信息后进入FIN_WAIT_2状态，如果这个时候B直接跑路，则A将永远处于这个状态，TCP协议没有对这个状态的处理，但是Linux有，可以调整**tcp.fin_timeout**这个参数设置一个超时
>
> 如果B没有跑路，发送了释放报文到达A时，A收到后回复确认信息的ACK之后，从FIN_WAIT_2状态结束
>
> 按理说这时候A可以跑路了，但是最后A发送的ACK，它无法确认B是否能够收到，如果B没有收到，那么B将重新发送释放连接报文，如果这时候A已经跑路了的话，B就再也收不到ACK了。所以TCP协议规定，A最后还要等待最后一段时间TIME_WAIT，这个时间要足够长，长到如果 B 没收到 ACK 的话，B的释放连接报文会重发，A 会重新发一个 ACK 并且足够时间到达 B。 等待的时间设为2MLS(MLS是报文最大生存时间)超过这个时间的报文将会被丢弃。协议规定MLS时间为2分钟。
>
> 这里还有一个异常情况，B超过了2MLS 还是没有收到它发送的FIN的ACK，那么它会重新发送FIN给A，这时候A再收到这个包之后表示，我已经在这等了这么长的时间了，仁至义尽了，于是直接发送RST给B，B就知道A已经跑路了。

### 顺序问题和丢包问题

TCP 协议为了保证顺序性，每一个包都有一个 ID。在建立连接的时候，会商定起始的 ID 是什么，然后按照 ID 一个个发送。为了保证不丢包，对于发送的包都要进行应答，但是这个应答也不是一个一个来的，而是会应答某个之前的 ID，表示都收到了，这种模式称为累计确认或者累计应答（cumulative acknowledgment）。

为了记录所有发送的包和接收的包，TCP 也需要发送端和接收端分别都有缓存来保存这些记录。发送端的缓存里是按照包的 ID 一个个排列，根据处理的情况分成四个部分

第一部分：发送了并且已经确认的。

第二部分：发送了并且尚未确认的。

第三部分：没有发送，但是已经等待发送的。

第四部分：没有发送，并且暂时还不会发送的。

在 TCP 里，接收端会给发送端报一个窗口的大小，叫 Advertised window。这个窗口的大小应该等于上面的第二部分加上第三部分，就是已经交代了没做完的加上马上要交代的。超过这个窗口的，接收端做不过来，就不能发送了。

于是，发送端需要保持下面的数据结构。

![t8Wb9K.jpg](https://s1.ax1x.com/2020/06/01/t8Wb9K.jpg)

- LastByteAcked：第一部分和第二部分的分界线
- LastByteSent：第二部分和第三部分的分界线
- LastByteAcked + AdvertisedWindow： 第三部分和第四部分的分界线

对于接收端来讲，它的缓存里记录的内容要简单一些。

第一部分：接受并且确认过的。

第二部分：还没接收，但是马上就能接收的。

第三部分：还没接收，也没法接收的。

对应的数据结构就像这样。

![t8fpNt.jpg](https://s1.ax1x.com/2020/06/01/t8fpNt.jpg)

- MaxRcvBuffer：最大缓存的量；
- LastByteRead 之后是已经接收了，但是还没被应用层读取的；
- NextByteExpected 是第一部分和第二部分的分界线。

 下面结合一个例子来看:

还是刚才的图，在发送端来看，1、2、3 已经发送并确认；4、5、6、7、8、9 都是发送了还没确认；10、11、12 是还没发出的；13、14、15 是接收方没有空间，不准备发的。

在接收端来看，1、2、3、4、5 是已经完成 ACK，但是没读取的；6、7 是等待接收的；8、9 是已经接收，但是没有 ACK 的。

发送端和接收端当前的状态如下：

- 1、2、3 没有问题，双方达成了一致。
- 4、5 接收方说 ACK 了，但是发送方还没收到，有可能丢了，有可能在路上。
- 6、7、8、9 肯定都发了，但是 8、9 已经到了，但是 6、7 没到，出现了乱序，缓存着但是没办法 ACK。

根据这个例子可以看出顺序问题和丢包问题随时都会出现，那么现在先来看确认与重发机制



假设 4 的确认到了，不幸的是，5 的 ACK 丢了，6、7 的数据包丢了，以下有几种解决方法

> 一种方法就是超时重试，也即对每一个发送了，但是没有 ACK 的包，都有设一个定时器，超过了一定的时间，就重新尝试。这个时间不宜过短，时间必须大于往返时间 RTT，否则会引起不必要的重传。也不宜过长，这样超时时间变长，访问就变慢了。
>
> 估计往返时间，需要 TCP 通过采样 RTT 的时间，然后进行加权平均，算出一个值，而且这个值还是要不断变化的，因为网络状况不断地变化。除了采样 RTT，还要采样 RTT 的波动范围，计算出一个估计的超时时间。由于重传时间是不断变化的，我们称为自适应重传算法（Adaptive Retransmission Algorithm）。
>
> 如果过一段时间，5、6、7 都超时了，就会重新发送。接收方发现 5 原来接收过，于是丢弃 5；6 收到了，发送 ACK，要求下一个是 7，7 不幸又丢了。当 7 再次超时的时候，有需要重传的时候，TCP 的策略是超时间隔加倍。每当遇到一次超时重传的时候，都会将下一次超时时间间隔设为先前值的两倍。两次超时，就说明网络环境差，不宜频繁反复发送。
>
> 超时触发重传存在的问题是，超时周期可能相对较长。有一个可以快速重传的机制，当接收方收到一个序号大于下一个所期望的报文段时，就会检测到数据流中的一个间隔，于是它就会发送冗余的 ACK，仍然 ACK 的是期望接收的报文段。而当客户端收到三个冗余的 ACK 后，就会在定时器过期之前，重传丢失的报文段。
>
> 例如，接收方发现 6 收到了，8 也收到了，但是 7 还没来，那肯定是丢了，于是发送 6 的 ACK，要求下一个是 7。接下来，收到后续的包，仍然发送 6 的 ACK，要求下一个是 7。当客户端收到 3 个重复 ACK，就会发现 7 的确丢了，不等超时，马上重发。

> 还有一种方式称为 Selective Acknowledgment （SACK）。这种方式需要在 TCP 头里加一个 SACK 的东西，可以将缓存的地图发送给发送方。例如可以发送 ACK6、SACK8、SACK9，有了地图，发送方一下子就能看出来是 7 丢了。

### 流量控制问题

在对于包的确认中，同时还会携带一个窗口的大小

先假设窗口不变的情况，窗口始终为 9。4 的确认来的时候，会右移一个，这个时候第 13 个包也可以发送了。

![t8htsg.jpg](https://s1.ax1x.com/2020/06/01/t8htsg.jpg)

这个时候，假设发送端发送过猛，会将第三部分的 10、11、12、13 全部发送完毕，之后就停止发送了，未发送可发送部分为 0。

![t8hdds.jpg](https://s1.ax1x.com/2020/06/01/t8hdds.jpg)

当对于包 5 的确认到达的时候，在客户端相当于窗口再滑动了一格，这个时候，才可以有更多的包可以发送了，例如第 14 个包才可以发送。

![t8hBiq.jpg](https://s1.ax1x.com/2020/06/01/t8hBiq.jpg)

如果接收方实在处理的太慢，导致缓存中没有空间了，可以通过确认信息修改窗口的大小，甚至可以设置为 0，则发送方将暂时停止发送。

假设一个极端情况，接收端的应用一直不读取缓存中的数据，当数据包 6 确认后，窗口大小就不能再是 9 了，就要缩小一个变为 8。

![t8hfoR.jpg](https://s1.ax1x.com/2020/06/01/t8hfoR.jpg)

这个新的窗口 8 通过 6 的确认消息到达发送端的时候，你会发现窗口没有平行右移，而是仅仅左面的边右移了，窗口的大小从 9 改成了 8。

![t8hXTA.jpg](https://s1.ax1x.com/2020/06/01/t8hXTA.jpg)

如果接收端还是一直不处理数据，则随着确认的包越来越多，窗口越来越小，直到为 0。

![t84pSf.jpg](https://s1.ax1x.com/2020/06/01/t84pSf.jpg)

当这个窗口通过包 14 的确认到达发送端的时候，发送端的窗口也调整为 0，停止发送。

![t84C6S.jpg](https://s1.ax1x.com/2020/06/01/t84C6S.jpg)

如果这样的话，发送方会定时发送窗口探测数据包，看是否有机会调整窗口的大小。当接收方比较慢的时候，要防止低能窗口综合征，别空出一个字节来就赶快告诉发送方，然后马上又填满了，可以当窗口太小的时候，不更新窗口，直到达到一定大小，或者缓冲区一半为空，才更新窗口。





