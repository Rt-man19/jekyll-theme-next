# Scala

## Heloworld

```scala
object helloworld {
    def main(args: Array[String]): Unit = {
        println("hello world")
    }
}
```



## 定义变量

在Scala中定义变量有两种方式， var 和 val 

使用val定义的变量无法再次被更改

使用var定义的变量可以被更改

```scala
scala> var a: String = 'hello'
scala> val b: String = 'world'
scala> a = 'world'

scala> b = 'hello'
<console>:12: error: reassignment to val
       b = "hello"
         ^
scala> println(a,b)
(world,world)
```

## 语句

### if

Scala中的if表达式最终结果为Unit

if/else 的结果基于表达式的每个部分的类型。

例子:

```scala
//if 表达式
if (ture) println ("end if")
// if 代码块
if (true) {
    println("line 1")
    println("line 2")
}
// 三元运算符
val i: Int = if (true) 1 else 3
```

### for

for语句提供了迭代集合的能力,还提供了过滤选项和生成新集合的能力

```scala
//基本语法
val list = List("A","B","C","D","E")
for ( l <- list) {
    println(l)
}
// 过滤
for (l <- list if l.contains("D")) {
    println(l)
} 
// 过滤条件可以写多个
for (l <- list 
    if l.contains("D") && if !l.startWith("E")
    ) println(l)
```

### while 

while 循环执行一个代码块

```scala
var i = 0
while (i < 5) {
    println(i)
    i = i + 1
}
```

### 模式匹配

模式匹配允许在多个条件之间进行选择

```scala
def printNum(i: Int) {
    i match {
        case 0 => println("zero")
        case 1 => println("one")
        case _ => println("more than one")
    }
}
printNum(0) //zero
printNum(1) //one
printNum(2) //more than one
```

下划线"_" 在模式匹配是通配符，表示任何未定义在上面的情况 

**测试数据类型**

```scala
def test(in: Any) = in match {
    case s: String => "String, length" + s.length
    case i: Int if i > 0 => "Natrual Int"
    case i: Int => "Another Int"
    case a: AnyRef => a.getClass.getName
    case _ => "null"
}
```



## 函数

**定义函数的语法格式**

```text
def 函数名 (参数名: 参数类型...): 返回值类型 = {
	函数体
}
```

***例子：***

```scala
def hello(name: String): Unit = {
    println(s"hello $name")
}

hello("zk")

hello zk
```

**匿名函数**

```scala
var increment = (x: Int) => x+1
```

### 高阶函数

scala中的高阶函数是相对于MapReduce而言

#### map

```scala
val l = List(1,2,3,4,5,6)
// map 操作的是l中的每一个元素
// 写法1
l.map(x=>x*2)
// 写法2
// _表示集合中的每一个元素
l.map(_*2)
println(l2)
//返回: List(2, 4, 6, 8, 10, 12)
println(l3) 
//返回: List(2, 4, 6, 8, 10, 12)
```

#### filter 

filter表示对元素进行过滤

```scala
//过滤出l中大于4的元素
l.filter(_>4) 
//返回： l4: List[Int] = List(5, 6)
```

#### reduce

reduce有两个变种 reduceLeft和reduceRight

**reduce**

reduce表示对元素进行计算

```scala
l.reduce(_+_)
//返回： 21
l.reduce(_-_)
//返回: -19
```

**reduceLeft**

reduceLeft表示对元素从左往右计算

```scala
l.reduceLeft(_+_)
//返回: 21
l.reduceLeft(_-_)
//返回: -19  
```

**reduceRight**

reduceRight 表示对元素从右往左计算

```scala
l.reduceRight(_+_)
//返回: 21
l.reduceRight(_-_)
//返回: -3
```

#### fold

fold函数将一种格式的输入数据转化成另外一种格式返回

```scala
l.fold(0) { (x,y) => x+y}
// 返回: 21
```

List中的fold方法需要输入两个参数：初始值以及一个函数。输入的函数也需要输入两个参数：累加值和当前item的索引

#### flatten

```scala
val l2 = List(List(1,2),List(3,4))
l2.flatten
//返回  List[Int] = List(1, 2, 3, 4)
```

#### flatmap

效果等于flatten + map

```scala
l2.flatmap(x => x.map(_*2))
//返回 List(2, 4, 6, 8)
```

### 

## 面向对象

### class类

**定义class的语法格式**

```scala
class Person {
    // 属性
    var name = "" // name肯定是一个字符串类型
    // 方法
    // 方法可以有参也可以无参
    def eat() = {
        println(s"$name eat")
    }
    def py(pyname: String): Unit = {
        println(pyname)
    }
}

// class 是要new出来之后才能使用
// 在new的时时候会把class中的语句全都执行一遍
val person = new Person()
person.name = "zk"
println(people.eat())
people.py("ZK")
```

### 构造方法

**主构造器**

```scala
class Person(val name: String, val city: String){
    println("Person enter")
    
    println("Person out")
}
val person = new Person("zk","bj")
println(person.name + ":" + person.city)
// 输出: Person enter
//      Person out
//      zk:bj
```

**附属构造器**

```scala
class Person(val name: String, val city: String){
    println("Person enter")
    
    // 固定语法，def this().
    def this(name: String, city: String, age: Int){
        this(name,city)
        this.age = age
    }
    // 附属构造器第一行一定要调用主构造器或者其他附属构造器
    
    println("Person out")
}
//附属构造器的使用
val person2 = new Person("zk","sz","21")
println(person2.name + ":" + person2.city + ":" + person2.age )
// 输出: Person enter
//      Person out
//      zk:bj:21
```



### 抽象类

抽象类就是class类中没有具体的实现,抽象类使用abstract修饰

```scala
object AbstractApp {
    def main(args: Array[String]): Unit {
        val a = new B()
        a.speak
    }
}
abstract class A {
    def speak
    val name: String
}
// 抽象类不能直接new，需要有一个子类来实现它，再去new
// 这个子类不能还是抽象的
class B extends A {
    override def speak(): Unit = {
    	println("B speak")
    }
    override val name: String = "zk"
}
```





### 继承

**基本语法**

```scala
class Zk(name: Sting, city: String,money: Float) extends Person(name,city){
    println("zk enter")
    
    println("zk out")
}
object zkdemo {
    def main(args: Array[String]): Unit {
        val zk1 = new Zk("zk","bj",10000.0f)
    }
}

// 输出:println("Person enter")
//     println("Person out")
//	   zk enter
//	   zk enter
// new 子类，一定会先调用父类的东西
```

**重写**

```scala
class Zk(name: Sting, city: String,money: Float) extends Person(name,city){
    println("zk enter")
    
    // 在子类中重写父类的属性或方法使用override修饰
    // 但是override不能重写父类中被var修饰的属性
    override def toString() = "zk to String"
    
    println("zk out")
}
object zkdemo {
    def main(args: Array[String]): Unit {
        val zk1 = new Zk("zk","bj",10000.0f)
        //调用方法时默认走父类的方法，如果子类中也有同名方法则调用子类中的方法
        println(zk1.toString()) 
    }
}
// 输出:println("Person enter")
//     println("Person out")
//	   zk enter
//	   zk enter
//     zk to String
```

